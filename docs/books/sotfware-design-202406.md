# Software Design 202407

## Bun

Node.js は以下の問題を抱えていた。

- `package.json`や`node_modules`などによるパッケージ管理の複雑さ
- CJS/ESM の混在による複雑さ
- TypeScript の非サポート

これらを解消すべく Deno が生み出された。

- `package.json`や`node_modules`、CJS 廃止
- テストランナー・バンドラーの同梱
- TS の標準サポート

しかし、Deno は Node.js との互換性がなく、移行はあまり進んでいない。これを踏まえ、Bun は Node.js と Deno の中間的な特徴を持って誕生した。

- パッケージマネージャー、テストランナー、バンドラー、TS トランスパイラをすべて同梱しており追加作業が不要
  - npm/yarn/jest/webpack/esbuild/babel などがすべて不要
- とにかく速い
- Node.js/Jest と互換性を持つ
  - ドロップインリプレイスメントになることを目指している

Bun CLI というツールが含まれており、この CLI を使って様々な作業を行う。

- `bun run <file path>` ファイルを実行
- `bun run <script name>` package.json スクリプトを実行
- `bun x <package name` npx の代わり。`bunx`でもよい。
- `bun exec "echo hello"` シェルスクリプトを実行
- `bun install` パッケージのインストール
- `bun add <package name>` パッケージの追加
- `bun remove <package name>` パッケージの削除
- `bun update` semver に沿って最新化
- `bun link/unlink` 外部パッケージのリンク/アンリンク
  - yarn link と同じ
  - dependencies に`"pkg_a": "link:pkg_a"`のように書かれる
- `bun pm` パッケージマネージャーの使い方
- `bun pm bin (-g)` bin フォルダのパスを表示
- `bun pm ls` パッケージを一覧表示
- `bun pm cache (rm)` キャッシュフォルダを表示/削除
- `bun test` テストを実行する
- `bun test -t <filename>` 特定の名前を含むテストファイルを実行
- `bun test <filepath>` 特定のテストファイルを実行
- `bun build ./index.ts` バンドルして JS ファイルとして出力する（ベータ版）
- `bun compile ./index.ts` 実行可能バイナリとしてコンパイルする

## 実行計画インデックスの仕組み

### RDBMS と SQL の基礎概念

#### リレーショナルモデルとは

リレーショナルモデル（関係モデル）とは、データモデルの一種である。

データモデルとは、データの表現方法と、演算の定義の組み合わせからなる。

リレーショナルモデルが扱うデータの単位は**リレーション/関係**と呼ばれる。特別な構造をもった、数学的な意味での「集合」の一種であり、順序も重複もない。リレーショナルモデルでは、このリレーションを値として演算を行う。

つまり、リレーショナルモデルとは、リレーションという集合がどのようなものであるか、そしてそれに対する演算はどのようなものかを定義したものである。

#### リレーションの構造

リレーションは**ヘッダ/見出し**と**ボディ/本体**からなる。

なお、単に「リレーション」といった場合は、一般的に「ボディの全部」を指す。

ヘッダは**属性**を持つ。属性とは属性値にどのようなデータが含まれるかを定義したもので、**名前とデータ型**を持つ。データ型も、また集合である。

ボディは**タプル/組**の集合であり、タプルは**属性値**の集合である。どのような属性値が含まれるかはヘッダに定義されているため、結果としてタプルはみんな同じ構造を持つことになる。

※以下は便宜上テーブルとして表現しているものの、リレーションは集合であるため、順序はない。本来はベン図などで表すべきである。

| 学生 ID | 名前     | 年齢 | 学年 |
| ------- | -------- | ---- | ---- |
| 1       | 田中太郎 | 20   | 2 年 |
| 2       | 鈴木花子 | 19   | 1 年 |

- ヘッダ: 学生 ID, 名前, 年齢, 学年
- ボディ: 各学生のデータが格納されている部分
- タプル: 田中太郎さんのデータ (1, 田中太郎, 20, 2 年)
- 属性値: 「田中太郎」, 「20」など
- 属性: 学生 ID, 名前, 年齢, 学年
- 名前と型: 名前(VARCHAR), 年齢(INT) など

#### リレーショナルモデルの演算

演算は、1 つ又は複数のリレーションを入力として、1 つのリレーションを出力するものである。これにより、リレーションの演算はその結果をまた別の演算の入力として利用することができる。以下のような種類がある。

#### 射影 / Project

ヘッダから特定の属性のみを取り出し、タプルの属性を絞り込む演算。

重複は取り除かれる（集合には重複は存在しないため）。

e.g. 従業員のモデルから職位を重複なく抽出する

#### 制限 / Restrict

特定の条件を持つタプルだけをリレーションから選出する演算。

e.g. 従業員のモデルから入社日が 2018 年以降の社員を選出する

#### 和 / Union

集合和、つまり足し合わせたものを求める演算。同じヘッダを持つリレーション同士でしか行えない演算。重複は取り除かれる。

#### 積 / Intersect

集合積、つまり共通部分を求める演算。同じヘッダを持つリレーション同士でしか行えない演算。重複は取り除かれる。

#### 結合 / Join

SQL にはいろいろな結合があるが、リレーショナルモデルにおける結合は自然結合の一種類しかない。

自然結合は 2 つのリレーションを入力とし、まずは 2 つのリレーションに共通して存在する属性を見つけ、それらの属性の値が等しいタプル同士を見つけて合体させて新たなタプルとしていき、最終的にそのタプルの集合を出力する演算。

ヘッダが全く同じ 2 つのリレーションを入力とする場合、結果は積と同じになる。積は結合の特殊パターンといえる。

ヘッダに共通部分が全くない場合、結果は直積/Product となり、総当たり（タプルの総数 x タプルの総数）の組み合わせとなる。

#### SQL とリレーショナルモデルの関係性

SQL においてリレーションの概念を体現している要素は以下の通り。

- テーブル: リレーション
- カラム: 属性
- レコード: タプル

SQL の演算の入力はテーブルであり、出力もまたテーブルに相当するものであるという点が非常に重要である。

SQL の演算とリレーショナルモデルでの演算は以下のように対応する。実は SELECT は 3 つの演算を同時に行っているのである。

```sql
SELECT employee_name -- 射影
FROM employees -- 結合 (ここではJOINはしていないけど)
WHERE hire_date > '2018-01-01'; -- 制限
```

和は UNION で、積は JOIN で代用できる。

テーブルは以下の特徴もち、つまりリレーションではないため、演算の用語はリレーショナルモデルと SQL では異なっている。

- 行に順序がある
- 行が重複できる
- NULL を持てる

逆に、これらの特徴を可能な限りテーブルから取り除いておけば、リレーショナルモデルの利点を最大限引き出すことができる。たとえば、宣言的にクエリを記述することが可能になる。とはいえデータがリレーショナルモデルの範疇に収まるかどうかは、データの性質によるため、見極めが大事である。

#### リレーショナルモデルとインデックス

リレーショナルモデルとインデックスの親和性は低い。

そもそもインデックスや、インデックスを使って実装されている主キーというものは、リレーショナルモデルには存在しない。インデックスは RDBMS のベンダーごとに異なる実装の話である。キーも、リレーショナルモデルに存在するのは「候補キー」という「タプルを一意に特定するための属性の組み合わせのうち、属性の数が最小になるもの」が定義されているのみである。

#### SQL にあってリレーショナルモデルにないもの

- インデックス
  - 詳細前述
- 更新
  - リレーションは値であり、更新できない。1 を別の値にするなんでできないでしょ？
- トランザクション
  - 更新がないのでトランザクションもない
- クエリ以外の SQL コマンド
  - GRANT, REVOKE, BEGIN, COMMIT,,,
- NULL
  - 未知の値は集合の要素になることはできない
- ソート
  - 集合に順序はない

### SQL 実行の仕組みと実行計画

#### SQL 実行の流れ

- パーサーが SQL 文を解析し、AST（抽象構文木）を作成する。
- オプティマイザが AST を解析し、実行計画を作成してエグゼキュータに渡す。
  - コストベースオプティマイザを使用して最適化を行う。
    - 同じ結果を生み出す複数の AST をヒューリスティックに洗い出し、その中から最もコストが低いものを選ぶ。
    - 見積もりが常に正確であるわけではない。
  - ルールベースオプティマイザも存在するが、これは過去の遺物である。
  - 実行計画はクエリを効率的に実行するためのステップを具体化したもので、AST の形式で表現される。
- エグゼキュータが実行計画に基づいてテーブルからデータを読み取り、必要な加工を行った後、結果をクライアントに返す。

#### EXPLAIN コマンド

- id
  - 結合（JOIN）に対して振られる番号
  - MySQL ではクエリの実行単位は結合である
  - 1 つの FROM 句でいくつ JOIN しようと、1 つの結合としてカウントされる
- select_type
  - そのテーブルへのアクセスがなぜ必要だったかを示す
  - 単純な JOIN なら SIMPLE になる。そのほか、PRIMARY, SUBQUERY, DERIVED, UNION などがある。
  - id と select_type を見ていけば、全体の構造がわかる。苦手なら TREE 形式での出力にするとよい。
- table
  - どのテーブルへのアクセスか
  - テーブル名よりもエイリアス名が優先して表示される
- partitions
  - アクセスするパーティション
  - パーティショニングが有効になっている場合にのみ意味をもつ項目
  - パーティションの刈り込み(Partition pruning)が行われているかどうかを確認できる
    - 必要なパーティションだけをアクセスし、不要なパーティションを無視することでクエリの効率を高める技術
- type
  - テーブルアクセスの方法
  - Join type や Access type と呼ばれる
  - 効率が良いかどうかが一目瞭然でわかる
  - `const`,`eq`,`eq_ref`あたりは効率よし
  - `ALL`, `index`あたりは効率悪し
    - `index`はインデックス全体がスキャンされるという意味であり、語感に反して効率は悪いので注意
- possible_keys
  - インデックスの候補一覧
- key
  - 実際に使われたインデックス
- key_len
  - 実際に使われたインデックスのサイズをバイトで表したもの
- ref
  - インデックスを使うときに、なんの値で検索されるかを示す
  - インデックスが使用されない場合は空欄になる
  - リテラル値の場合は`const`、 別のテーブルのカラムの場合は`table_name.col_name`の形式で表示される。
- rows
  - 駆動表の 1 行につき、どれだけの行が返されるかの見積もり
  - オプティマイザが見誤りやすい項目
- filtered
  - WHERE 句などによりフィルタリングした結果、残ったデータの割合
  - 最大値は 100 で、これはフィルタリングが行われなかった（全て必要なデータだった）ことを意味します。
  - 最小値は 0 で、これはフィルタリングにより全てのデータが除外された（全て不要なデータだった）ことを表す
  - `rows * (filtered / 100)`が、次のステップでテーブルと結合されるデータの件数となる。
  - 前のステップで意味のあるデータ群に絞り込めているかという指標とも言える。
- Extra
  - その他ヒントになりそうな情報など
  - よくあるのは`Using where`で、これは「ここで Where 句が実行されましたよ」という意味
    - Where 句の実行はフルテーブルスキャンなどを発生させる可能性があるので、type と合わせてよく見ておくとよい

#### コストの把握

コストの把握にはなんといっても行数を見るのが大事。

例えば、t1,t2,t3,t4 の 4 つのデーブルを順に取得し、フィルタ後に残った件数(`rows * (filtered / 100)`)を t1_filtered, t2_filtered, t3_filtered, t4_filtered とすると、コストは以下のように計算できる。

```txt
t1 +
t2 * t1_filtered +
t3 * t1_filtered * t2_filtered +
t4 * t1_filtered * t2_filtered * t3_filtered
```

これを見ると、後になるほどコストがかかることがわかる。コスト改善のポイントは以下の 2 つ。

- 内部表の取り出しがどれだけ効率的に行われるか
  - 前述の t1, t2, t3, t4 が内部表を表す
  - インデックスを使って効率的にアクセスすることが重要
  - filtered の値はこの段階ではパフォーマンスと関係がないので注意
    - フィルタリングはテーブルから行を取得した**あと**に行われる
    - このため、いくらフィルタされたとしても自身のテーブルへのアクセスにおいてはパフォーマンスとは関係がない
    - あくまで後段の処理のパフォーマンスに影響する
- 駆動表においてどれだけ行数を絞り込めるか
  - 前述の`t*_filterd`の部分が絞り込まれたあとの駆動表を表す
  - ここではじめて filtered の値が効いてくる

#### 表形式以外の EXPLAIN

- TREE 形式
  - `EXPLAIN FORMAT=TREE`とすると、テーブル形式ではなくツリー形式で説明を出力できる
  - コストの値が表示される。特に単位はなく、あくまでも抽象的・相対的な値である点に注意。
- EXPLAIN ANALYZE
  - 実際の時間を計測する
  - TREE 形式の上位互換
