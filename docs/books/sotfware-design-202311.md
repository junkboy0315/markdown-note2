# Software Design 202310

## 個人開発成功の必須条件

### 最速で開発・リリースして需要を見極める

- 個人開発のメリット
  - モダンな技術を使える
  - ソフトウェア開発の全体像が見える
  - やりたいことをやれる
- 失敗しないためには
  - 先に集客＆マネタイズ
    - Airbnb はサービス開発する前に自分たちのオフィスをレンタルして本当に人が来るか見極めたらしい
    - インスタで DM 送って使ってもらって課金してくれそうか様子を見るとか
    - Google フォームで事前登録をしてもらい、連絡先を確保したうえ、課金してでも使いたいか聞いておくとか
  - 休日 2 日〜3 日で開発してリリース
    - コアのコアのコアだけを開発する
    - 99％は失敗するので、正しい設計とか、スケールできる構成とか、自由度の高い設計とか、利益出てから考えるで十分
    - 最初はほとんど手動でもいい、後で自動化する
  - お金をかけない

### 長期的視点でスモールビジネスを続ける

- 個人開発の良さ
  - 得た経験を本業に活かせる
  - 次の仕事につながる
  - すべての工程を体験できる
  - 自分のサービスが使われる感動を得られる
- 作りきれない問題の原因と対策
  - 構想が大きすぎる
    - まずは 1 ヶ月で作れるものを
    - 要件は削りまくってまずは MVP を作る
    - なる早でユーザーに使ってもってフィードバックを得る（恐れるな）
  - 技術的なハードルが高すぎる
    - 未経験な技術は使っても 1 つまで
    - 技術習得とサービス開発はわけて考える
      - 技術習得している段階では進捗がないように見えて病むので
    - まずは動かすことが最優先
      - リファクタは後でやる
      - 動的な部分であっても一旦は静的にしておく
      - PC だけ、iOS だけ、などデバイスを絞る
      - CSS を一切書かない、あとで書く
      - 外注する (Consumer Generated Media 等の場合は人が作ったデータがあるだけで完成度が違う)
  - 先に似たサービスが出てしまった
    - 気にしないでいい or 目に余る場合はピボット
  - 誰にも使われなかった
    - 自分でとにかく使う
    - 自分がほしい部分をとにかく作る
    - 恥を捨てて宣伝する
    - 1 人でも使い続けるモチベーションがある仕組みにする
- 金銭的成功を目指すためには
  - スモールビジネスをやる not スタートアップ
  - お金のかからない構成にしておく
  - 波が来るまでじっくり待つ
  - アップデートをし続ける（これできてないひと多いよ！必須よ！）
  - 他のことを捨てて時間を作る
  - 収益を出せる前提のサービスにする（無料プランはやらない、とか）

### 1 つのアプリをじっくり育てる

- 仕事の種類
  - フロー型の仕事 / 人月の切り売り / 受託
  - ストック型の仕事 / お金を生み出す仕組みに投資する / 個人開発
- サービスを軌道に乗せるには
  - ヘルプや初回起動時のガイドを作る
    - 最大の敵は「わからない」
  - 企業を超えたウェットなサポート
  - 無料機能と有料機能のバランスをよく考える
    - サブスクに一切お金を払わない日本人ばかりだったのは 10 年前の話
    - 広告ほど不安定な収入源はない
  - 新規アプリ作成に逃げずじっくり育てる
  - 辛辣なレビューに向き合う
    - ちゃんと直せば星 5 になおしてくれたりするよ
- 個人開発の成功とは、他人の評価軸に左右されず、自分のやりたいことをやり続けられること

## Go 言語のエラー処理 (後編)

- カスタムエラー構造体の命名
  - XxxError という名前にするのが Go の慣習

```go
type XxxError struct {
    Msg string
    File string
    Line int
}

func (e *XxxError) Error() string {
    return fmt.Sprintf("%s:%d: %s", e.File, e.Line, e.Msg)
}
```

- 事前定義エラー変数の命名
  - ErrXxx という名前にするのが Go の慣習
  - エラー文字列
    - 原則小文字で書く
    - 句読点は入れない
    - パッケージ名を入れておくとよい

```go
// errors.New()はシンプルに文字列からエラー変数を生成するときに使える便利な関数
var ErrNotFound = errors.New("not found")
```

- 値とエラーを混ぜない
  - Go は多値返却が可能なので、処理結果とエラーを同一の変数で返す必要性がない
- nil と型あり nil を使い分ける
  - `err != nil` で判定したときに、型あり nil は常に`true`となってしまう
  - Go 初学者がやりがちなミス

```go
// 明示的なnil
return nil

// 型ありnil
var e *MyError = nil
return e
```

- defer 文の中で発生したエラーの扱い方
  - 以下の 2 つの組み合わせでうまく処理できる(詳細は本文参照)
    - 名前付き戻り値の仕組みを使う
    - 本筋の処理で発生したエラーが、defer 文内で発生したエラーで上書きされないよう、`errors.Join()`を使ってエラーのマージ等を行う
- エラーのラップと判定
  - エラー A の原因となったエラー B という因果関係を表現するために、`Unwrap()`メソッドによるエラーのラップを行う場合がある
  - `errors.Is()`
    - ラップされたエラーを`Unwrap`し続けると、最終的に判定対象のエラーと同じ型に到達するかどうかを判定する
  - `errors.As()`
    - `error.Is()`と同等の判定を行うのに加え、マッチした場合にはその値を取り出すことができる
