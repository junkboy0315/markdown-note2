# Web + DB vol.136

## JavaScript 非同期処理

### 非同期処理の変遷

- 変遷
  - コールバック
  - Promise チェーン
  - async/await
- 非同期処理の構成要素
  - タスク
    - プログラムの実行単位
  - キュー
    - タスクキュー
  - イベント
    - タスクが格納されるタイミングに関係する
    - プログラムが特定の状態になったときに発生する
      - e.g. ボタンがクリックされた、通信処理が完了した、など

### なぜ非同期処理は難しいのか

- 非同期処理の目的
  - ブロッキングを防ぎながら、効率的なコードを書くこと
- 並行と並列
  - 並行 / Concurrency / ある時間内に複数の処理を実行すること
  - 並列 / Parallelism / あるタイミングで複数の計算が実際に実行されている
- 非同期処理には 2 つの種類がある
  - JavaScript の機能として提供されるもの
    - e.g. Promise, async / await
    - JavaScript の範疇で動くため、シングルスレッドである
      - JavaScript の機能は基本的に並行であり並列ではない
      - 待ち時間を重ね合わせて効率化している程度の話
  - 実行環境から API として提供されるもの
    - e.g. setTimeout など
    - JavaScript の範疇ではないため、マルチスレッド・マルチプロセスもありうる
    - 同期 API と非同期 API がある。後者が非同期処理の本質
- API の種類
  - Web API
    - 標準仕様がある
    - Browser API ともいう
    - setTimeout, fetch など
    - ブラウザでもサーバサイドでも動くことが多い
  - Runtime API
    - 標準仕様がない
    - 非ブラウザ環境で独自実装されている
    - 便宜上そう呼んだだけで正式名称ではない
- タスクの種類
  - タスク
    - コード全体の初回評価、UI レンダリング、setTimeout() など
  - マイクロタスク
    - Promise.then()など
- 実行順
  - イベントループ
  - 1 つのタスクが終わったら、全てのマイクロタスクを片付けて、またタスクの処理に戻る、以後繰り返し

### Promise とは

- then()の仕組み
  - 新たな Promise オブジェクトを返す
    - コールバック関数が：
      - Promise を返したら、そのオブジェクト
      - Promise 以外を返したら、その値を解決値とする Promise オブジェクト
      - 例外を送出したら、その値を失敗値として返す Promise オブジェクト
  - catch()は then()の糖衣構文である
    - then()の第 2 引数に失敗時のコールバック関数を渡した場合と同じ
- このあたりは自前で Promise を実装してみると一発で分かる

### async / await 深掘り

- async / await は単なる then の糖衣構文ではなく、動作が全く異なるので注意
  - for 文の中で利用した場合など
- 余談だが、then() という名前の関数は使わないほうが吉

### AbortSignal

- Promise を命令的に中断する手段
- AbortSignal というオブジェクトで制御する
  - 使える場所の例：
    - fetch() の第 2 引数内
    - window.addEventListener() の第 3 引数内
- JavaScript ではなく DOM 仕様の一部
  - だが Node.js 環境等にも広く移植されている
- AbortController というオブジェクトを介して AbortSignal を生成する
- signal により中断された場合、非同期処理の結果は失敗として扱われるのが通常
  - DOMExeption という例外が発生する
  - name が `AbortError` である

### AsyncLocalStorage

## 脆いテスト

- 自動テストを書く動機
  - 不具合混入を防止する
  - 問題箇所の絞り込みを容易にする
  - 動く仕様書になる
  - ソフトウェアの成長を持続可能なものにする（コレが一番大事）
    - 変更しやすく、変更に対応できるソフトウェアが競争力になる時代だから
- 保守性
  - モジュール性
  - 再利用性
  - 解析性（理解容易性）
  - 修正性（変更容易性）
  - 試験性（テスト容易性）
- 自動テストは最後の 2 つを向上させる
- 保守性とは、現状維持力ではなく、反応速度、改善力、推進力と考えろ
- よくある意見
  - 設計が変わりやすいのでテストを書くコストが高い
  - テストの修正コストが大きい
  - 設計が固まらないからテストが書けない
- 脆いテスト
  - 偽陽性のひとつ
  - コードが正しいにもかかわらずテストが失敗する誤検知のこと
  - ちな、コードに一切手を加えていないのにテストが失敗するのは「信頼不能テスト(Flaky Test)」という
- 脆いテストの原因
  - テストコードとテスト対象の高すぎる構造的結合度
- 指針
  - 公開 API 経由でテストする
    - 実装の詳細はテストしない
  - 構造単位ではなく振る舞い単位でテストする
    - クラスやメソッド、関数単位でテストを書かない
    - 振る舞いや責務に対してテストを書く
      - 1 つの関数が 3 つの仕事を請け負うなら 3 つのテストを書く
  - 相互作用ではなく事後状態をテストする
    - テスト対象の依存対象までモックしてテストなどをやり出すのは諸刃の剣
    - あくまで外部から見た振る舞いをテストする
      - e.g. テスト対象のメソッドの戻り値
      - e.g. テスト対象のメソッド実行後の状態
